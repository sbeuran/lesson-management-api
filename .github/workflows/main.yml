name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      env:
        AWS_DEFAULT_REGION: eu-west-1
        TESTING: "true"
        AWS_ACCESS_KEY_ID: testing
        AWS_SECRET_ACCESS_KEY: testing
        AWS_SECURITY_TOKEN: testing
        AWS_SESSION_TOKEN: testing
        MOTO_ACCOUNT_ID: '123456789012'
      run: |
        python -m pytest tests/ --cov=src --cov-report=term-missing -v
        
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-west-1
    
    - name: Get AWS account ID
      id: get-aws-account
      run: |
        echo "AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install mangum
        
    - name: Create deployment package
      run: |
        mkdir -p package
        cp -r src/* package/
        cp requirements.txt package/
        cd package
        zip -r ../deployment.zip ./*
        
    - name: Deploy to AWS
      run: |
        # Create DynamoDB table if it doesn't exist
        aws dynamodb create-table \
          --table-name lesson_completions \
          --attribute-definitions \
            AttributeName=student_id,AttributeType=S \
            AttributeName=id,AttributeType=S \
          --key-schema \
            AttributeName=student_id,KeyType=HASH \
            AttributeName=id,KeyType=RANGE \
          --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
          --region eu-west-1 || true
        
        # Create IAM role for Lambda if it doesn't exist
        aws iam create-role \
          --role-name lambda-role \
          --assume-role-policy-document '{
            "Version": "2012-10-17",
            "Statement": [{
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              }
            }]
          }' || true
        
        # Attach necessary policies to the role
        aws iam attach-role-policy \
          --role-name lambda-role \
          --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole || true
        
        aws iam attach-role-policy \
          --role-name lambda-role \
          --policy-arn arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess || true
        
        # Add API Gateway management permissions
        aws iam put-role-policy \
          --role-name lambda-role \
          --policy-name "APIGatewayManagement" \
          --policy-document '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "apigateway:POST",
                  "apigateway:GET",
                  "apigateway:PUT",
                  "apigateway:PATCH",
                  "apigateway:DELETE"
                ],
                "Resource": "*"
              }
            ]
          }'
        
        # Wait for role to be ready
        sleep 10
        
        # Create Lambda function if it doesn't exist, update if it does
        function_name="lesson-completion-api"
        
        if aws lambda get-function --function-name $function_name 2>&1 | grep -q "Function not found"; then
          # Create new function
          aws lambda create-function \
            --function-name $function_name \
            --runtime python3.9 \
            --handler src.api.lambda_handler.handler \
            --role "arn:aws:iam::$AWS_ACCOUNT_ID:role/lambda-role" \
            --zip-file fileb://deployment.zip
        else
          # Update existing function
          aws lambda update-function-code \
            --function-name $function_name \
            --zip-file fileb://deployment.zip
        fi

        # Create or update API Gateway
        api_name="lesson-completion-api"
        
        # Check if API exists
        existing_api_id=$(aws apigateway get-rest-apis --query "items[?name=='${api_name}'].id" --output text) || true
        
        if [ -z "$existing_api_id" ]; then
          # Create new API
          api_id=$(aws apigateway create-rest-api \
            --name "${api_name}" \
            --query 'id' \
            --output text)
          
          # Get root resource ID
          root_resource_id=$(aws apigateway get-resources \
            --rest-api-id "${api_id}" \
            --query 'items[?path==`/`].id' \
            --output text)
          
          # Create resource for /health
          health_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${root_resource_id}" \
            --path-part "health" \
            --query 'id' \
            --output text)
          
          # Create resource for /lessons
          lessons_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${root_resource_id}" \
            --path-part "lessons" \
            --query 'id' \
            --output text)
          
          # Create resource for /lessons/completion
          completion_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${lessons_resource_id}" \
            --path-part "completion" \
            --query 'id' \
            --output text)
          
          # Create resource for /lessons/completion/{student_id}
          student_completion_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${completion_resource_id}" \
            --path-part "{student_id}" \
            --query 'id' \
            --output text)
          
          # Create all methods
          for endpoint in "${health_resource_id}:GET" "${health_resource_id}:OPTIONS" "${completion_resource_id}:POST" "${completion_resource_id}:GET" "${completion_resource_id}:OPTIONS" "${student_completion_resource_id}:GET" "${student_completion_resource_id}:OPTIONS"; do
            resource_id="${endpoint%:*}"
            method="${endpoint#*:}"
            
            # Create method
            if [ "${method}" = "OPTIONS" ]; then
              # Special handling for OPTIONS method
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method OPTIONS \
                --authorization-type NONE

              # Add OPTIONS method response
              aws apigateway put-method-response \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters "method.response.header.Access-Control-Allow-Headers=true,method.response.header.Access-Control-Allow-Methods=true,method.response.header.Access-Control-Allow-Origin=true"

              # Add OPTIONS integration
              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method OPTIONS \
                --type MOCK \
                --request-templates '{"application/json":"{\"statusCode\": 200}"}'

              # Add OPTIONS integration response
              aws apigateway put-integration-response \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters "{
                  \"method.response.header.Access-Control-Allow-Headers\": \"'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'\",
                  \"method.response.header.Access-Control-Allow-Methods\": \"'GET,POST,OPTIONS'\",
                  \"method.response.header.Access-Control-Allow-Origin\": \"'*'\"
                }"
            else
              # Regular method setup (existing code)
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method "${method}" \
                --authorization-type NONE \
                $([ "${resource_id}" = "${student_completion_resource_id}" ] && echo '--request-parameters "method.request.path.student_id=true"' || echo '')
              
              # Set up Lambda integration
              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method "${method}" \
                --type AWS_PROXY \
                --integration-http-method POST \
                --uri "arn:aws:apigateway:${AWS_DEFAULT_REGION}:lambda:path/2015-03-31/functions/arn:aws:lambda:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:function:${function_name}/invocations"
            fi
          done
          
          # Add Lambda permission for API Gateway
          aws lambda add-permission \
            --function-name "${function_name}" \
            --statement-id "AllowAPIGatewayInvoke" \
            --action "lambda:InvokeFunction" \
            --principal "apigateway.amazonaws.com" \
            --source-arn "arn:aws:execute-api:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:${api_id}/*/*"
          
          # Deploy the API
          aws apigateway create-deployment \
            --rest-api-id "${api_id}" \
            --stage-name "prod"

          # ALWAYS create/update API key and usage plan
          echo "Creating/updating API key..."
          api_key_response=$(aws apigateway create-api-key \
            --name "lesson-completion-api-key" \
            --enabled \
            --generate-distinct-id \
            --description "API key for lesson completion API" \
            --tags Key=Environment,Value=prod)
          
          api_key_id=$(echo "$api_key_response" | jq -r '.id')
          api_key_value=$(echo "$api_key_response" | jq -r '.value')
          
          echo "Creating/updating usage plan..."
          usage_plan_response=$(aws apigateway create-usage-plan \
            --name "lesson-completion-api-plan" \
            --description "Usage plan for lesson completion API" \
            --api-stages "[{\"apiId\": \"${api_id}\", \"stage\": \"prod\"}]" \
            --throttle '{"rateLimit": 10, "burstLimit": 5}' \
            --quota '{"limit": 1000, "period": "MONTH"}')
          
          usage_plan_id=$(echo "$usage_plan_response" | jq -r '.id')
          
          echo "Associating API key with usage plan..."
          aws apigateway create-usage-plan-key \
            --usage-plan-id "${usage_plan_id}" \
            --key-id "${api_key_id}" \
            --key-type "API_KEY" || true

          # Update all methods to require API key
          echo "Updating methods to require API key..."
          resources=$(aws apigateway get-resources --rest-api-id "${api_id}" --query 'items[*].[id]' --output text)
          for resource_id in $resources; do
            methods=$(aws apigateway get-resource --rest-api-id "${api_id}" --resource-id "${resource_id}" --query 'resourceMethods' --output text)
            for method in $methods; do
              if [ "$method" != "OPTIONS" ]; then
                aws apigateway update-method \
                  --rest-api-id "${api_id}" \
                  --resource-id "${resource_id}" \
                  --http-method "${method}" \
                  --patch-operations op=replace,path=/apiKeyRequired,value=true || true
              fi
            done
          done

          # Create new deployment to apply changes
          echo "Creating new deployment..."
          aws apigateway create-deployment \
            --rest-api-id "${api_id}" \
            --stage-name "prod" \
            --description "Deployment with API key requirement"

          # Output results
          echo "Setup complete!"
          echo "API Base URL: https://${api_id}.execute-api.${AWS_DEFAULT_REGION}.amazonaws.com/prod"
          echo "API Key: ${api_key_value}"
        else
          api_id="${existing_api_id}"
        fi

        # ALWAYS create/update API key and usage plan
        echo "Creating/updating API key..."
        api_key_response=$(aws apigateway create-api-key \
          --name "lesson-completion-api-key" \
          --enabled \
          --generate-distinct-id \
          --description "API key for lesson completion API" \
          --tags Key=Environment,Value=prod)
        
        api_key_id=$(echo "$api_key_response" | jq -r '.id')
        api_key_value=$(echo "$api_key_response" | jq -r '.value')
        
        echo "Creating/updating usage plan..."
        usage_plan_response=$(aws apigateway create-usage-plan \
          --name "lesson-completion-api-plan" \
          --description "Usage plan for lesson completion API" \
          --api-stages "[{\"apiId\": \"${api_id}\", \"stage\": \"prod\"}]" \
          --throttle '{"rateLimit": 10, "burstLimit": 5}' \
          --quota '{"limit": 1000, "period": "MONTH"}')
        
        usage_plan_id=$(echo "$usage_plan_response" | jq -r '.id')
        
        echo "Associating API key with usage plan..."
        aws apigateway create-usage-plan-key \
          --usage-plan-id "${usage_plan_id}" \
          --key-id "${api_key_id}" \
          --key-type "API_KEY" || true

        # Update all methods to require API key
        echo "Updating methods to require API key..."
        resources=$(aws apigateway get-resources --rest-api-id "${api_id}" --query 'items[*].[id]' --output text)
        for resource_id in $resources; do
          methods=$(aws apigateway get-resource --rest-api-id "${api_id}" --resource-id "${resource_id}" --query 'resourceMethods' --output text)
          for method in $methods; do
            if [ "$method" != "OPTIONS" ]; then
              aws apigateway update-method \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method "${method}" \
                --patch-operations op=replace,path=/apiKeyRequired,value=true || true
            fi
          done
        done

        # Create new deployment to apply changes
        echo "Creating new deployment..."
        aws apigateway create-deployment \
          --rest-api-id "${api_id}" \
          --stage-name "prod" \
          --description "Deployment with API key requirement"

        # Output results
        echo "Setup complete!"
        echo "API Base URL: https://${api_id}.execute-api.${AWS_DEFAULT_REGION}.amazonaws.com/prod"
        echo "API Key: ${api_key_value}"
        
  