name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      env:
        AWS_DEFAULT_REGION: eu-west-1
        TESTING: "true"
        AWS_ACCESS_KEY_ID: testing
        AWS_SECRET_ACCESS_KEY: testing
        AWS_SECURITY_TOKEN: testing
        AWS_SESSION_TOKEN: testing
        MOTO_ACCOUNT_ID: '123456789012'
      run: |
        python -m pytest tests/ --cov=src --cov-report=term-missing -v
        
    - name: Start Moto server
      run: |
        pip install moto[server]
        moto_server dynamodb -p5000 &
        sleep 5  # Wait for server to start
        
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-west-1
    
    - name: Get AWS account ID
      id: get-aws-account
      run: |
        echo "AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install mangum
        
    - name: Create deployment package
      run: |
        mkdir -p package
        cp -r src/* package/
        cp requirements.txt package/
        cd package
        zip -r ../deployment.zip ./*
        
    - name: Deploy to AWS
      run: |
        # Create DynamoDB table if it doesn't exist
        aws dynamodb create-table \
          --table-name lesson_completions \
          --attribute-definitions \
            AttributeName=student_id,AttributeType=S \
            AttributeName=id,AttributeType=S \
          --key-schema \
            AttributeName=student_id,KeyType=HASH \
            AttributeName=id,KeyType=RANGE \
          --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
          --region eu-west-1 || true
        
        # Create IAM role for Lambda if it doesn't exist
        aws iam create-role \
          --role-name lambda-role \
          --assume-role-policy-document '{
            "Version": "2012-10-17",
            "Statement": [{
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              }
            }]
          }' || true
        
        # Attach necessary policies to the role
        aws iam attach-role-policy \
          --role-name lambda-role \
          --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole || true
        
        aws iam attach-role-policy \
          --role-name lambda-role \
          --policy-arn arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess || true
        
        # Add API Gateway management permissions
        aws iam put-role-policy \
          --role-name lambda-role \
          --policy-name "APIGatewayManagement" \
          --policy-document '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "apigateway:POST",
                  "apigateway:GET",
                  "apigateway:PUT",
                  "apigateway:PATCH",
                  "apigateway:DELETE"
                ],
                "Resource": "*"
              }
            ]
          }'
        
        # Wait for role to be ready
        sleep 10
        
        # Create or update Lambda function
        function_name="lesson-completion-api"
        
        # Check if function exists
        if aws lambda get-function --function-name $function_name >/dev/null 2>&1; then
          echo "Updating existing Lambda function..."
          
          # Update function code
          aws lambda update-function-code \
            --function-name $function_name \
            --zip-file fileb://deployment.zip
          
          # Wait for update to complete
          echo "Waiting for Lambda update to complete..."
          sleep 10
          
          # Update configuration
          echo "Updating Lambda configuration..."
          aws lambda update-function-configuration \
            --function-name $function_name \
            --timeout 30 \
            --memory-size 256
        else
          echo "Creating new Lambda function..."
          # Create new function
          aws lambda create-function \
            --function-name $function_name \
            --runtime python3.9 \
            --handler src.api.lambda_handler.handler \
            --role "arn:aws:iam::$AWS_ACCOUNT_ID:role/lambda-role" \
            --timeout 30 \
            --memory-size 256 \
            --zip-file fileb://deployment.zip
        fi

        # Wait for function to be ready
        echo "Waiting for Lambda function to be ready..."
        sleep 10

        # Add Lambda permission for API Gateway
        echo "Adding Lambda permission for API Gateway..."
        aws lambda add-permission \
          --function-name $function_name \
          --statement-id apigateway \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:${api_id}/*/*" || true

        # Create or update API Gateway
        api_name="lesson-completion-api"
        
        # Check if API exists
        existing_api_id=$(aws apigateway get-rest-apis --query "items[?name=='${api_name}'].id" --output text) || true
        
        if [ -z "$existing_api_id" ]; then
          # Create new API with CORS enabled
          api_id=$(aws apigateway create-rest-api \
            --name "${api_name}" \
            --endpoint-configuration types=REGIONAL \
            --query 'id' \
            --output text)
        else
          api_id="${existing_api_id}"
        fi
        
        # Get root resource ID
        root_resource_id=$(aws apigateway get-resources \
          --rest-api-id "${api_id}" \
          --query 'items[?path==`/`].id' \
          --output text)
        
        # Create /lessons resource if it doesn't exist
        lessons_resource_id=$(aws apigateway get-resources \
          --rest-api-id "${api_id}" \
          --query "items[?path=='/lessons'].id" \
          --output text) || true
        
        if [ -z "$lessons_resource_id" ]; then
          lessons_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${root_resource_id}" \
            --path-part "lessons" \
            --query 'id' \
            --output text)
        fi
        
        # Create /lessons/completion resource if it doesn't exist
        completion_resource_id=$(aws apigateway get-resources \
          --rest-api-id "${api_id}" \
          --query "items[?path=='/lessons/completion'].id" \
          --output text) || true
        
        if [ -z "$completion_resource_id" ]; then
          completion_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${lessons_resource_id}" \
            --path-part "completion" \
            --query 'id' \
            --output text)
        fi
        
        # Set up methods for /lessons/completion
        for method in GET POST OPTIONS; do
          aws apigateway get-method \
            --rest-api-id "${api_id}" \
            --resource-id "${completion_resource_id}" \
            --http-method "${method}" 2>/dev/null || {
            
            if [ "${method}" = "OPTIONS" ]; then
              # OPTIONS method setup
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method OPTIONS \
                --authorization-type NONE \
                --no-api-key-required

              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method OPTIONS \
                --type MOCK \
                --request-templates '{"application/json":"{\"statusCode\": 200}"}'

              aws apigateway put-method-response \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters "{
                  \"method.response.header.Access-Control-Allow-Headers\":true,
                  \"method.response.header.Access-Control-Allow-Methods\":true,
                  \"method.response.header.Access-Control-Allow-Origin\":true
                }"

              aws apigateway put-integration-response \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters '{
                  "method.response.header.Access-Control-Allow-Headers": "'\''Content-Type,X-Api-Key,Authorization'\''",
                  "method.response.header.Access-Control-Allow-Methods": "'\''GET,POST,OPTIONS'\''",
                  "method.response.header.Access-Control-Allow-Origin": "'\''*'\''"
                }'
            else
              # Regular method setup
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method "${method}" \
                --authorization-type NONE \
                --api-key-required

              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${completion_resource_id}" \
                --http-method "${method}" \
                --type AWS_PROXY \
                --integration-http-method POST \
                --uri "arn:aws:apigateway:${AWS_DEFAULT_REGION}:lambda:path/2015-03-31/functions/arn:aws:lambda:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:function:${function_name}/invocations"
            fi
          }
        done

        # Check if student_id resource exists
        student_completion_resource_id=$(aws apigateway get-resources \
          --rest-api-id "${api_id}" \
          --query "items[?path=='/lessons/completion/{student_id}'].id" \
          --output text) || true

        if [ -z "$student_completion_resource_id" ]; then
          echo "Creating student_id resource..."
          student_completion_resource_id=$(aws apigateway create-resource \
            --rest-api-id "${api_id}" \
            --parent-id "${completion_resource_id}" \
            --path-part "{student_id}" \
            --query 'id' \
            --output text)
        else
          echo "Student_id resource already exists"
        fi

        # Set up methods for student_id endpoint
        for method in GET OPTIONS; do
          # Check if method exists
          aws apigateway get-method \
            --rest-api-id "${api_id}" \
            --resource-id "${student_completion_resource_id}" \
            --http-method "${method}" 2>/dev/null || {
            
            if [ "${method}" = "OPTIONS" ]; then
              # OPTIONS method setup
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method OPTIONS \
                --authorization-type NONE \
                --no-api-key-required

              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method OPTIONS \
                --type MOCK \
                --request-templates '{"application/json":"{\"statusCode\": 200}"}'

              aws apigateway put-method-response \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters "{
                  \"method.response.header.Access-Control-Allow-Headers\":true,
                  \"method.response.header.Access-Control-Allow-Methods\":true,
                  \"method.response.header.Access-Control-Allow-Origin\":true
                }"

              aws apigateway put-integration-response \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters '{
                  "method.response.header.Access-Control-Allow-Headers": "'\''Content-Type,X-Api-Key,Authorization'\''",
                  "method.response.header.Access-Control-Allow-Methods": "'\''GET,OPTIONS'\''",
                  "method.response.header.Access-Control-Allow-Origin": "'\''*'\''"
                }'
            else
              # GET method setup
              aws apigateway put-method \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method GET \
                --authorization-type NONE \
                --api-key-required \
                --request-parameters "method.request.path.student_id=true"

              aws apigateway put-integration \
                --rest-api-id "${api_id}" \
                --resource-id "${student_completion_resource_id}" \
                --http-method GET \
                --type AWS_PROXY \
                --integration-http-method POST \
                --uri "arn:aws:apigateway:${AWS_DEFAULT_REGION}:lambda:path/2015-03-31/functions/arn:aws:lambda:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:function:${function_name}/invocations" \
                --request-parameters "integration.request.path.student_id=method.request.path.student_id"
            fi
          }
        done

        # Add Lambda permission for student_id endpoint
        aws lambda add-permission \
          --function-name $function_name \
          --statement-id apigateway-student \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:${api_id}/*/GET/lessons/completion/*" || true

        # Create deployment
        aws apigateway create-deployment \
          --rest-api-id "${api_id}" \
          --stage-name "prod"
        
        # Output the API URL
        echo "API URL: https://${api_id}.execute-api.${AWS_DEFAULT_REGION}.amazonaws.com/prod"

        # ALWAYS create/update API key and usage plan
        echo "Creating/updating API key..."
        api_key_response=$(aws apigateway create-api-key \
          --name "lesson-completion-api-key" \
          --enabled \
          --generate-distinct-id \
          --description "API key for lesson completion API" \
          --tags Key=Environment,Value=prod)
        
        api_key_id=$(echo "$api_key_response" | jq -r '.id')
        api_key_value=$(echo "$api_key_response" | jq -r '.value')
        
        echo "Creating/updating usage plan..."
        usage_plan_response=$(aws apigateway create-usage-plan \
          --name "lesson-completion-api-plan" \
          --description "Usage plan for lesson completion API" \
          --api-stages "[{\"apiId\": \"${api_id}\", \"stage\": \"prod\"}]" \
          --throttle '{"rateLimit": 10, "burstLimit": 5}' \
          --quota '{"limit": 1000, "period": "MONTH"}')
        
        usage_plan_id=$(echo "$usage_plan_response" | jq -r '.id')
        
        echo "Associating API key with usage plan..."
        aws apigateway create-usage-plan-key \
          --usage-plan-id "${usage_plan_id}" \
          --key-id "${api_key_id}" \
          --key-type "API_KEY" || true

        # Update all methods to require API key
        echo "Updating methods to require API key..."
        resources=$(aws apigateway get-resources --rest-api-id "${api_id}" --query 'items[*].[id]' --output text)
        for resource_id in $resources; do
          methods=$(aws apigateway get-resource --rest-api-id "${api_id}" --resource-id "${resource_id}" --query 'resourceMethods' --output text)
          for method in $methods; do
            if [ "$method" != "OPTIONS" ]; then
              aws apigateway update-method \
                --rest-api-id "${api_id}" \
                --resource-id "${resource_id}" \
                --http-method "${method}" \
                --patch-operations op=replace,path=/apiKeyRequired,value=true || true
            fi
          done
        done

        # Create new deployment to apply changes
        echo "Creating new deployment..."
        aws apigateway create-deployment \
          --rest-api-id "${api_id}" \
          --stage-name "prod" \
          --description "Deployment with API key requirement"

        # Output results
        echo "Setup complete!"
        echo "API Base URL: https://${api_id}.execute-api.${AWS_DEFAULT_REGION}.amazonaws.com/prod"
        echo "API Key: ${api_key_value}"

        # Add method responses for non-OPTIONS methods
        for method in GET POST; do
          aws apigateway put-method-response \
            --rest-api-id "${api_id}" \
            --resource-id "${completion_resource_id}" \
            --http-method "${method}" \
            --status-code 200 \
            --response-models '{"application/json": "Empty"}' || true

          aws apigateway put-integration-response \
            --rest-api-id "${api_id}" \
            --resource-id "${completion_resource_id}" \
            --http-method "${method}" \
            --status-code 200 \
            --selection-pattern "" || true
        done

        # Update Lambda permissions
        aws lambda remove-permission \
          --function-name $function_name \
          --statement-id apigateway || true

        # Update method responses and integrations
        for method in GET POST; do
          aws apigateway put-method-response \
            --rest-api-id "${api_id}" \
            --resource-id "${completion_resource_id}" \
            --http-method "${method}" \
            --status-code 200 \
            --response-models '{"application/json": "Empty"}' \
            --response-parameters "{
              \"method.response.header.Access-Control-Allow-Origin\": true,
              \"method.response.header.Access-Control-Allow-Methods\": true,
              \"method.response.header.Access-Control-Allow-Headers\": true
            }" || true

          aws apigateway put-integration-response \
            --rest-api-id "${api_id}" \
            --resource-id "${completion_resource_id}" \
            --http-method "${method}" \
            --status-code 200 \
            --selection-pattern "" \
            --response-parameters "{
              \"method.response.header.Access-Control-Allow-Origin\": \"'*'\",
              \"method.response.header.Access-Control-Allow-Methods\": \"'GET,POST,OPTIONS'\",
              \"method.response.header.Access-Control-Allow-Headers\": \"'Content-Type,X-Api-Key'\"
            }" || true
        done

        # Update Lambda permissions with timestamp
        timestamp=$(date +%s)
        aws lambda add-permission \
          --function-name $function_name \
          --statement-id "apigateway-${timestamp}" \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${AWS_DEFAULT_REGION}:${AWS_ACCOUNT_ID}:${api_id}/*/*/*"
        
  